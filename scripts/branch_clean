#!/usr/bin/env bash
set -euo pipefail

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Config / Defaults â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
REMOTE="origin"; AUTHOR_RE=""; ONLY="all"; BASE=""
HELP=0; RAW=0; NO_COLUMN=0; INTERACTIVE=0; CACHE_PR=0; DRY_RUN=0
LOG_LEVEL="info"    # info|debug|trace
COLOR_MODE="auto"   # auto|always|never
SORT_COL=""; SORT_DESC=0
PR_CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/branch_clean"
PR_CACHE_TTL=3600  # Cache TTL in seconds (default: 1 hour)

# Widths when RAW=0 (prevent macOS column choking)
W_BRANCH=60; W_SCOPE=6; W_UPSTREAM=48; W_UPSTREAMDATE=18
W_MERGED=12; W_PR=12; W_PRSTATE=12; W_DATE=18; W_EMAIL=48

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CLI Args â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
while [ $# -gt 0 ]; do
  case "$1" in
    -a|--author) AUTHOR_RE="${2:-}"; shift 2;;
    -r|--remote) REMOTE="${2:-}"; shift 2;;
    -b|--base)   BASE="${2:-}"; shift 2;;
    --locals-only) ONLY="local"; shift;;
    --remotes-only) ONLY="remote"; shift;;
    -i|--interactive) INTERACTIVE=1; shift;;
    --cache-pr) CACHE_PR=1; shift;;
    --dry-run) DRY_RUN=1; shift;;
    --sort) 
      VALID_SORTS="branch|scope|upstream|upstream_updated|merged|pr|pr_state|last_update|email"
      if [ -n "${2:-}" ] && ! printf '%s' "$VALID_SORTS" | grep -qE "(^|\\|)${2}(\\||$)"; then
        printf 'Invalid --sort value: %s. Valid options: %s\n' "$2" "$VALID_SORTS" >&2
        exit 2
      fi
      SORT_COL="${2:-}"; shift 2;;
    --desc) SORT_DESC=1; shift;;
    --raw) RAW=1; shift;;
    --no-column) NO_COLUMN=1; shift;;
    --log-level) LOG_LEVEL="${2:-info}"; shift 2;;
    --color) COLOR_MODE="${2:-auto}"; shift 2;;
    --debug) LOG_LEVEL="debug"; shift;;
    --trace) LOG_LEVEL="trace"; shift;;
    -h|--help) HELP=1; shift;;
    *) printf 'Unknown arg: %s\n' "$1" >&2; exit 2;;
  esac
done

if [ "$HELP" = "1" ]; then
  cat <<'EOF'
Usage: branch_clean [options]
  -a, --author REGEX       Filter by email (regex, case-insensitive)
  -r, --remote NAME        Remote (default: origin)
  -b, --base BRANCH        Base to compare merge against (default: repo default)
      --locals-only        Only local branches
      --remotes-only       Only remote branches
  -i, --interactive        Interactive mode with fzf (select branches to act on)
      --cache-pr           Cache PR data to avoid repeated GitHub API calls (1hr TTL)
      --dry-run            Show what would be deleted without actually deleting (use with -i)
      --sort COL           Sort by: branch|scope|upstream|upstream_updated|merged|pr|pr_state|last_update|email
      --desc               Sort descending
      --raw                Disable truncation (very long lines)
      --no-column          Disable column(1) alignment
      --color MODE         auto|always|never (default: auto)
      --log-level LVL      info|debug|trace
      --debug|--trace      Shorthand for higher log verbosity
Notes:
  * Dates are relative across all ranges (min, hr, day, week, month, year).
  * PR columns use GitHub `gh` + `jq`. If unavailable/empty, they're "-".
  * Interactive mode requires `fzf` (brew install fzf).
  * PR cache is stored in ${XDG_CACHE_HOME:-$HOME/.cache}/branch_clean/
EOF
  exit 0
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
lvl_num(){ case "$1" in trace) echo 3;; debug) echo 2;; info) echo 1;; warn) echo 0;; *) echo 1;; esac; }
LOG_CUR=$(lvl_num "$LOG_LEVEL")
ts(){ date +"%Y-%m-%d %H:%M:%S"; }
log(){ local L="$1"; shift; local N=$(lvl_num "$L"); [ "$N" -le "$LOG_CUR" ] || return 0; echo "[$(ts)] [$L] $*" >&2; }
warn(){ log warn "$@"; }
info(){ log info "$@"; }
dbg(){ log debug "$@"; }
trc(){ log trace "$@"; }

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Color Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
is_tty=0; [ -t 1 ] && is_tty=1
supports_color=0; command -v tput >/dev/null 2>&1 && [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ] && supports_color=1
case "$COLOR_MODE" in
  always) DO_COLOR=1;;
  never)  DO_COLOR=0;;
  *)      DO_COLOR=$(( is_tty && supports_color ));;
esac

# Palette (synthwave-ish). Only used if DO_COLOR=1.
if [ "$DO_COLOR" -eq 1 ]; then
  C_HDR=$'\033[38;5;201m'   # neon magenta
  C_LOC=$'\033[38;5;51m'
  C_REM=$'\033[38;5;141m'
  C_OK=$'\033[38;5;82m'
  C_NO=$'\033[38;5;208m'
  C_CY=$'\033[38;5;45m'     # cyan
  C_DIM=$'\033[2m'
  C_RST=$'\033[0m'
else
  C_HDR=""; C_LOC=""; C_REM=""; C_OK=""; C_NO=""; C_CY=""; C_DIM=""; C_RST=""
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Repo / Base Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
git rev-parse --git-dir >/dev/null 2>&1 || { echo "Not a git repo." >&2; exit 2; }

if [ -z "${BASE}" ]; then
  if RH=$(git symbolic-ref -q "refs/remotes/${REMOTE}/HEAD" 2>/dev/null); then
    BASE="${RH##refs/remotes/${REMOTE}/}"
  else
    if   git show-ref --verify "refs/remotes/${REMOTE}/main"   >/dev/null 2>&1; then BASE="main"
    elif git show-ref --verify "refs/remotes/${REMOTE}/master" >/dev/null 2>&1; then BASE="master"
    else BASE=$(git rev-parse --abbrev-ref HEAD); fi
  fi
fi
BASE_REF=""
if   git show-ref --verify "refs/remotes/${REMOTE}/${BASE}" >/dev/null 2>&1; then BASE_REF="refs/remotes/${REMOTE}/${BASE}"
elif git show-ref --verify "refs/heads/${BASE}"             >/dev/null 2>&1; then BASE_REF="refs/heads/${BASE}"
else warn "Base '$BASE' not found; MERGED will be '-'."; fi
info "Base: $BASE (ref: ${BASE_REF:-N/A})"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PR preload (GitHub) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HAVE_GH=0; HAVE_JQ=0
command -v gh >/dev/null 2>&1 && HAVE_GH=1
command -v jq >/dev/null 2>&1 && HAVE_JQ=1
PRMAP=$(mktemp 2>/dev/null || mktemp -t prmap)
TMP_PRINT=""
UPSTREAMS_TMP=""
trap 'rm -f "$PRMAP" "$OUT" "$REFDATE" "$SORTED" "$TMP_PRINT" "$UPSTREAMS_TMP" "$PREVIEW_TMP" 2>/dev/null || true' EXIT

# Determine cache file path based on repo
PR_CACHE_FILE=""
USE_CACHE=0
if [ $CACHE_PR -eq 1 ]; then
  # Get repo identifier (owner/repo from remote URL)
  REPO_ID=$(git config --get remote.${REMOTE}.url 2>/dev/null || git remote get-url "$REMOTE" 2>/dev/null || echo "unknown")
  # Sanitize to create filename
  REPO_HASH=$(printf '%s' "$REPO_ID" | shasum -a 256 | cut -d' ' -f1)
  PR_CACHE_FILE="${PR_CACHE_DIR}/pr_cache_${REPO_HASH}.json"
  
  # Create cache directory if needed
  if [ ! -d "$PR_CACHE_DIR" ]; then
    mkdir -p "$PR_CACHE_DIR" 2>/dev/null || warn "Failed to create cache dir: $PR_CACHE_DIR"
  fi
  
  # Check if cache exists and is fresh
  if [ -f "$PR_CACHE_FILE" ]; then
    CACHE_AGE=$(( $(date +%s) - $(stat -f%m "$PR_CACHE_FILE" 2>/dev/null || stat -c%Y "$PR_CACHE_FILE" 2>/dev/null || echo 0) ))
    if [ "$CACHE_AGE" -lt "$PR_CACHE_TTL" ]; then
      USE_CACHE=1
      info "Using cached PR data (age: ${CACHE_AGE}s, TTL: ${PR_CACHE_TTL}s)"
    else
      dbg "Cache expired (age: ${CACHE_AGE}s > TTL: ${PR_CACHE_TTL}s)"
    fi
  fi
fi

PR_COUNT=0
if [ $HAVE_GH -eq 1 ] && [ $HAVE_JQ -eq 1 ]; then
  if [ $USE_CACHE -eq 1 ] && [ -f "$PR_CACHE_FILE" ]; then
    # Load from cache (already in TSV format, no jq needed!)
    if cat "$PR_CACHE_FILE" > "$PRMAP" 2>/dev/null; then
      PR_COUNT=$(wc -l < "$PRMAP" | tr -d ' ')
      if [ "$PR_COUNT" -gt 0 ]; then
        info "Loaded $PR_COUNT PRs from cache."
      fi
    else
      warn "Failed to read cache file, fetching fresh data..."
      USE_CACHE=0
    fi
  fi
  
  # Fetch fresh data if not using cache
  if [ $USE_CACHE -eq 0 ]; then
    PR_ERR=$(mktemp 2>/dev/null || mktemp -t prerr)
    if pr_json=$(gh pr list --state all --json number,state,headRefName --limit 1000 2>"$PR_ERR"); then
      # Transform with jq once and save directly to PRMAP
      if printf '%s' "$pr_json" | jq -r '.[] | "\(.headRefName)\t\(.number)\t\(.state)"' > "$PRMAP" 2>/dev/null; then
        PR_COUNT=$(wc -l < "$PRMAP" | tr -d ' ')
        if [ "$PR_COUNT" -gt 0 ]; then
          info "Loaded $PR_COUNT PRs via gh."
          
          # Save to cache if --cache-pr was used (save the TSV, not JSON!)
          if [ $CACHE_PR -eq 1 ] && [ -n "$PR_CACHE_FILE" ]; then
            cp "$PRMAP" "$PR_CACHE_FILE" 2>/dev/null && dbg "Cached PR data to $PR_CACHE_FILE" || warn "Failed to write cache"
          fi
        else
          warn "gh returned 0 PRs; auth/context may be missing. Try: gh auth status; gh repo view"
        fi
      else
        warn "jq transformation failed"
      fi
    else
      PR_ERR_MSG=$(sed -n '1,4p' "$PR_ERR" | tr -d '\n')
      if [ -z "$PR_ERR_MSG" ]; then
        warn "gh pr list failed; PR columns will be '-'."
      else
        warn "gh pr list failed; PR columns will be '-'. gh error: $PR_ERR_MSG"
      fi
    fi
    rm -f "$PR_ERR" 2>/dev/null || true
  fi
else
  warn "gh+jq not available; PR columns will be '-'."
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Upstream date map â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
REFDATE=$(mktemp 2>/dev/null || mktemp -t refdate)
git for-each-ref --format='%(refname)\t%(committerdate:iso-strict)' refs/heads refs/remotes > "$REFDATE"

# Build a list of upstream short names for local branches so we can skip the
# corresponding remote refs (avoids duplicate rows where a remote appears
# both as its own row and as the upstream column for a local branch).
UPSTREAMS_TMP=$(mktemp 2>/dev/null || mktemp -t upstreams)
git for-each-ref --format='%(upstream:short)' refs/heads | awk 'NF{print}' > "$UPSTREAMS_TMP"

# Derive PR URL base (assumes GitHub) so PR numbers can be rendered as
# clickable links in supporting terminals.
PR_URL_BASE=""
REPO_URL=$(git config --get remote.${REMOTE}.url 2>/dev/null || git remote get-url "$REMOTE" 2>/dev/null || true)
if [ -n "$REPO_URL" ]; then
  if [[ "$REPO_URL" =~ github\.com[:/]([^/]+/[^/]+)(\.git)?$ ]]; then
    OWNER_REPO="${BASH_REMATCH[1]}"
    PR_URL_BASE="https://github.com/${OWNER_REPO}/pull/"
  else
    R=$(printf '%s' "$REPO_URL" | sed -E 's#(git@[^:]+:|https?://[^/]+/)##; s#\.git$##')
    if [ -n "$R" ]; then PR_URL_BASE="https://github.com/${R}/pull/"; fi
  fi
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Date helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
norm_tz(){ echo "${1}" | sed -E 's@([+-][0-9]{2}):([0-9]{2})$@\1\2@'; }
to_epoch(){ if date -ud "@0" >/dev/null 2>&1; then date -ud "$1" +%s; else date -j -f '%Y-%m-%dT%H:%M:%S%z' "$(norm_tz "$1")" +%s; fi; }
plural(){ local n="$1" w="$2"; if [ "$n" -eq 1 ]; then echo "$n $w ago"; else echo "$n ${w}s ago"; fi; }
rel_or_iso(){
  local iso="$1"; [ -z "$iso" ] && { echo "-"; return; }
  local now epoch delta; now=$(date +%s)
  if ! epoch=$(to_epoch "$iso" 2>/dev/null); then echo "${iso%%T*}"; return; fi
  delta=$(( now - epoch )); [ $delta -lt 0 ] && delta=$(( -delta ))
  # Time constants for readability
  local m=$((60)); local h=$((60*m)); local d=$((24*h)); local w=$((7*d))
  local mo=$((30*d)); local y=$((365*d))
  if   [ $delta -lt $m ]; then echo "just now"
  elif [ $delta -lt $h ]; then plural $((delta/m)) "min"
  elif [ $delta -lt $d ]; then plural $((delta/h)) "hour"
  elif [ $delta -lt $w ]; then plural $((delta/d)) "day"
  elif [ $delta -lt $mo ]; then plural $((delta/w)) "week"
  elif [ $delta -lt $y ]; then plural $((delta/mo)) "month"
  else plural $((delta/y)) "year"; fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Gather refs (US-delimited) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SEP=$'\x1f'
REF_FMT="%(refname)${SEP}%(refname:short)${SEP}%(upstream:short)${SEP}%(committerdate:iso-strict)${SEP}%(authoremail)"
NS1="refs/heads"; NS2="refs/remotes"; case "$ONLY" in local) NS2="";; remote) NS1="";; esac

OUT=$(mktemp 2>/dev/null || mktemp -t branches_out)
printf "BRANCH\tSCOPE\tUPSTREAM\tUPSTREAM_UPDATED\tMERGED->%s\tPR\tPR_STATE\tLAST_UPDATE\tEMAIL\t__USISO\t__LASTISO\n" "$BASE" >"$OUT"

while IFS="$SEP" read -r REF FULL UPSTREAM LASTISO AEMAIL; do
  [ "$REF" = "refs/remotes/${REMOTE}/HEAD" ] && continue
  case "$REF" in refs/heads/*) SCOPE="local";; refs/remotes/*) SCOPE="remote";; *) SCOPE="-";; esac

  # Skip remote refs that are upstreams of local branches to avoid duplicates
  if [ "$SCOPE" = "remote" ] && [ -s "$UPSTREAMS_TMP" ]; then
    if grep -Fxq "$FULL" "$UPSTREAMS_TMP" 2>/dev/null; then
      continue
    fi
  fi

  [ -n "$AUTHOR_RE" ] && printf '%s\n' "$AEMAIL" | grep -qiE -- "$AUTHOR_RE" || { [ -n "$AUTHOR_RE" ] && continue; }

  # Upstream display rules
  if [ "$SCOPE" = "remote" ] || [ -z "${UPSTREAM}" ]; then UPSTREAM="-"; fi

  # Merge vs base
  MERGED="-"
  if [ -n "$BASE_REF" ] && [ "$FULL" != "$BASE" ] && [ "$REF" != "$BASE_REF" ]; then
    if git merge-base --is-ancestor "$REF" "$BASE_REF"; then MERGED="yes"; else MERGED="no"; fi
  fi

  # PR lookup
  PRNO="-" PRST="-"
  if [ -s "$PRMAP" ]; then
    if line=$(grep -m1 -F -E "^${FULL}\t" "$PRMAP" 2>/dev/null); then
      PRNO="#$(printf '%s' "$line" | awk -v FS=$'\t' '{print $2}')"
      PRST="$(printf '%s' "$line" | awk -v FS=$'\t' '{print $3}')"
    else
      SHORT="$FULL"; case "$SHORT" in */*) SHORT="${SHORT#*/}";; esac
      if line=$(grep -m1 -F -E "^${SHORT}\t" "$PRMAP" 2>/dev/null); then
        PRNO="#$(printf '%s' "$line" | awk -v FS=$'\t' '{print $2}')"
        PRST="$(printf '%s' "$line" | awk -v FS=$'\t' '{print $3}')"
      fi
    fi
  fi

  LAST_HUMAN=$(rel_or_iso "$LASTISO")

  USISO=""; UPSTREAM_UPDATED="-"
  if [ "$UPSTREAM" != "-" ]; then
    CAND1="refs/remotes/${UPSTREAM}"; CAND2="refs/heads/${UPSTREAM}"
    USISO=$(awk -v FS=$'\t' -v r="$CAND1" '$1==r{print $2; exit}' "$REFDATE" || true)
    [ -z "$USISO" ] && USISO=$(awk -v FS=$'\t' -v r="$CAND2" '$1==r{print $2; exit}' "$REFDATE" || true)
    [ -n "$USISO" ] && UPSTREAM_UPDATED=$(rel_or_iso "$USISO")
  fi

  # Emit TSV (+ hidden ISO fields for sorting)
  printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
    "$FULL" "$SCOPE" "$UPSTREAM" "$UPSTREAM_UPDATED" "$MERGED" "$PRNO" "$PRST" "$LAST_HUMAN" "$AEMAIL" "${USISO:-}"$'\t'"${LASTISO:-}" \
    >>"$OUT"
done < <(
  if [ -n "$NS1" ] && [ -n "$NS2" ]; then
    git for-each-ref --sort=-committerdate --format="$REF_FMT" "$NS1" "$NS2"
  elif [ -n "$NS1" ]; then
    git for-each-ref --sort=-committerdate --format="$REF_FMT" "$NS1"
  else
    git for-each-ref --sort=-committerdate --format="$REF_FMT" "$NS2"
  fi
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Sorting (uses hidden ISO fields) â”€â”€â”€â”€â”€â”€â”€â”€â”€
SORTED="$OUT"
if [ -n "$SORT_COL" ]; then
  case "$SORT_COL" in
    branch)           KEY=1;;
    scope)            KEY=2;;
    upstream)         KEY=3;;
    upstream_updated) KEY=10;;   # __USISO
    merged)           KEY=5;;
    pr)               KEY=6;;
    pr_state)         KEY=7;;
    last_update)      KEY=11;;   # __LASTISO
    email)            KEY=9;;
    *) warn "Unknown --sort '$SORT_COL' (ignored)"; KEY="";;
  esac
  if [ -n "${KEY:-}" ]; then
    SORTED="${OUT}.sorted"
    if [ $SORT_DESC -eq 1 ]; then sort -t $'\t' -k "${KEY},${KEY}" -r "$OUT" > "$SORTED"
    else                               sort -t $'\t' -k "${KEY},${KEY}"    "$OUT" > "$SORTED"
    fi
  fi
fi

# Strip hidden fields
TAB=$'\t'
cut -f1-9 "$SORTED" > "${SORTED}.vis" && mv "${SORTED}.vis" "$SORTED"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Truncate (if RAW=0) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [ $RAW -eq 0 ]; then
  awk -v FS="$TAB" -v OFS="$TAB" \
      -v WB="$W_BRANCH" -v WS="$W_SCOPE" -v WU="$W_UPSTREAM" -v WUD="$W_UPSTREAMDATE" \
      -v WM="$W_MERGED" -v WP="$W_PR" -v WPS="$W_PRSTATE" -v WD="$W_DATE" -v WE="$W_EMAIL" '
    function trunc(s, w) { nl=index(s,"\n"); if(nl){s=substr(s,1,nl-1)}; return (length(s)>w ? substr(s,1,w-1)"â€¦" : s) }
    NR==1 { print $1,$2,$3,$4,$5,$6,$7,$8,$9; next }
    { $1=trunc($1,WB); $2=trunc($2,WS); $3=trunc($3,WU); $4=trunc($4,WUD);
      $5=trunc($5,WM); $6=trunc($6,WP); $7=trunc($7,WPS); $8=trunc($8,WD); $9=trunc($9,WE);
      print $1,$2,$3,$4,$5,$6,$7,$8,$9 }' "$SORTED" > "${SORTED}.trim"
  mv "${SORTED}.trim" "$SORTED"
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Render (column â†’ color) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
render_plain() {
  if [ $NO_COLUMN -eq 0 ] && command -v column >/dev/null 2>&1; then
    column -t -s $'\t' < "$SORTED"
  else
    cat "$SORTED"
  fi
}

render_output() {
  if [ "$DO_COLOR" -eq 0 ]; then
    render_plain
  else
    TMP_PRINT=$(mktemp 2>/dev/null || mktemp -t printout)
    render_plain > "$TMP_PRINT"
    # Colorize after alignment without adding/removing characters
    awk -v hdr="$C_HDR" -v loc="$C_LOC" -v rem="$C_REM" -v ok="$C_OK" -v no="$C_NO" -v cy="$C_CY" -v dim="$C_DIM" -v rst="$C_RST" '
      NR==1 { print hdr $0 rst; next }
      {
        gsub(/\<local\>/,  loc "local" rst);
        gsub(/\<remote\>/, rem "remote" rst);
        gsub(/\<YES\>/,    ok "YES" rst);
        gsub(/\<yes\>/,    ok "yes" rst);
        gsub(/\<NO\>/,     no "NO" rst);
        gsub(/\<no\>/,     no "no" rst);
        gsub(/\<open\>/,   ok "open" rst);
        gsub(/\<merged\>/, cy "merged" rst);
        gsub(/\<closed\>/, no "closed" rst);
        gsub(/\<draft\>/,  dim "draft" rst);
        print
      }' "$TMP_PRINT" > "${TMP_PRINT}.colored"
    
    # If we have a PR URL base and perl is available, make PR numbers clickable with OSC8
    if [ -n "$PR_URL_BASE" ] && command -v perl >/dev/null 2>&1; then
      # OSC8: \e]8;;URL\e\\TEXT\e]8;;\e\\
      if perl -pe 's/(#(\d+))/sprintf("\e]8;;%s%s\e\\%s\e]8;;\e\\", $ENV{PR_URL_BASE}, $2, $1)/ge' "${TMP_PRINT}.colored" 2>/dev/null; then
        rm -f "${TMP_PRINT}.colored"
      else
        cat "${TMP_PRINT}.colored"
        rm -f "${TMP_PRINT}.colored"
      fi
    else
      cat "${TMP_PRINT}.colored"
      rm -f "${TMP_PRINT}.colored"
    fi
    rm -f "$TMP_PRINT"
  fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Interactive Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if [ "$INTERACTIVE" -eq 1 ]; then
  if ! command -v fzf >/dev/null 2>&1; then
    echo "Error: Interactive mode requires 'fzf'. Install with: brew install fzf" >&2
    exit 1
  fi
  
  if [ $DRY_RUN -eq 1 ]; then
    info "Entering interactive mode (DRY RUN - no changes will be made)"
  else
    info "Entering interactive mode (press ESC to exit)..."
  fi
  
  # Generate preview content without colors for fzf
  PREVIEW_TMP=$(mktemp 2>/dev/null || mktemp -t preview)
  if [ $NO_COLUMN -eq 0 ] && command -v column >/dev/null 2>&1; then
    column -t -s $'\t' < "$SORTED" > "$PREVIEW_TMP"
  else
    cat "$SORTED" > "$PREVIEW_TMP"
  fi
  
  # Use fzf for interactive selection
  SELECTED=$(tail -n +2 "$PREVIEW_TMP" | \
    fzf --ansi \
        --multi \
        --header="Select branches to DELETE (TAB for multi-select, ENTER to confirm)" \
        --preview='echo "Selected: {}" | head -20' \
        --preview-window=up:3:wrap \
        --bind='ctrl-a:select-all,ctrl-d:deselect-all' \
        --height=100%)
  
  rm -f "$PREVIEW_TMP"
  
  if [ -n "$SELECTED" ]; then
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Confirmation Table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo ""
    echo "${C_HDR}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RST}"
    echo "${C_HDR}Review Selected Branches for Deletion${C_RST}"
    echo "${C_HDR}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RST}"
    echo ""
    
    # Create confirmation table
    CONFIRM_TMP=$(mktemp 2>/dev/null || mktemp -t confirm)
    printf "# \tBRANCH\tSCOPE\tMERGED\tPR\n" > "$CONFIRM_TMP"
    
    COUNT=0
    while IFS= read -r line; do
      COUNT=$((COUNT + 1))
      BRANCH=$(echo "$line" | awk '{print $1}')
      SCOPE=$(echo "$line" | awk '{print $2}')
      MERGED=$(echo "$line" | awk '{print $5}')
      PR=$(echo "$line" | awk '{print $6}')
      
      printf "%d\t%s\t%s\t%s\t%s\n" "$COUNT" "$BRANCH" "$SCOPE" "$MERGED" "$PR" >> "$CONFIRM_TMP"
    done <<< "$SELECTED"
    
    # Display the table
    if command -v column >/dev/null 2>&1; then
      column -t -s $'\t' < "$CONFIRM_TMP"
    else
      cat "$CONFIRM_TMP"
    fi
    rm -f "$CONFIRM_TMP"
    
    echo ""
    echo "${C_HDR}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RST}"
    
    # Confirmation prompt (skip in dry-run mode)
    if [ $DRY_RUN -eq 0 ]; then
      echo ""
      echo -n "${C_NO}âš  WARNING: This will delete $COUNT branch(es).${C_RST} Continue? (y/N): "
      read -r CONFIRM
      echo ""
      
      if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
        echo "${C_CY}Deletion cancelled by user.${C_RST}"
        exit 0
      fi
    fi
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Proceed with Deletion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo ""
    echo "${C_HDR}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RST}"
    if [ $DRY_RUN -eq 1 ]; then
      echo "${C_HDR}DRY RUN - Branch Deletion Preview${C_RST}"
    else
      echo "${C_HDR}Deleting Selected Branches${C_RST}"
    fi
    echo "${C_HDR}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RST}"
    echo ""
    
    # Track statistics
    TOTAL=0; SUCCESS_LOCAL=0; SUCCESS_REMOTE=0; SKIPPED=0; FAILED=0
    
    # Process each selected line
    while IFS= read -r line; do
      TOTAL=$((TOTAL + 1))
      
      # Extract branch name and scope (first two columns)
      BRANCH=$(echo "$line" | awk '{print $1}')
      SCOPE=$(echo "$line" | awk '{print $2}')
      
      echo "${C_CY}[$TOTAL] Branch:${C_RST} $BRANCH ${C_DIM}(${SCOPE})${C_RST}"
      
      # Get current branch to prevent self-deletion
      CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
      
      # Safety check: don't delete current branch
      if [ "$BRANCH" = "$CURRENT_BRANCH" ]; then
        echo "  ${C_NO}âš  SKIP:${C_RST} Cannot delete current branch"
        SKIPPED=$((SKIPPED + 1))
        echo ""
        continue
      fi
      
      # Safety check: don't delete base branch
      if [ "$BRANCH" = "$BASE" ]; then
        echo "  ${C_NO}âš  SKIP:${C_RST} Cannot delete base branch ($BASE)"
        SKIPPED=$((SKIPPED + 1))
        echo ""
        continue
      fi
      
      # Delete based on scope
      case "$SCOPE" in
        local)
          if [ $DRY_RUN -eq 1 ]; then
            echo "  ${C_DIM}[DRY RUN]${C_RST} Would run: ${C_CY}git branch -D ${BRANCH}${C_RST}"
            SUCCESS_LOCAL=$((SUCCESS_LOCAL + 1))
          else
            if git branch -D "$BRANCH" >/dev/null 2>&1; then
              echo "  ${C_OK}âœ“ Deleted local branch${C_RST}"
              SUCCESS_LOCAL=$((SUCCESS_LOCAL + 1))
            else
              echo "  ${C_NO}âœ— Failed to delete local branch${C_RST}"
              FAILED=$((FAILED + 1))
            fi
          fi
          ;;
          
        remote)
          # Delete remote tracking branch locally
          
          if [ $DRY_RUN -eq 1 ]; then
            echo "  ${C_DIM}[DRY RUN]${C_RST} Would run: ${C_CY}git branch -D --remote ${BRANCH}${C_RST}"
            SUCCESS_REMOTE=$((SUCCESS_REMOTE + 1))
          else
            if git branch -D --remote "$BRANCH" >/dev/null 2>&1; then
              echo "  ${C_OK}âœ“ Deleted remote tracking branch${C_RST}"
              SUCCESS_REMOTE=$((SUCCESS_REMOTE + 1))
            else
              echo "  ${C_NO}âœ— Failed to delete remote tracking branch${C_RST}"
              FAILED=$((FAILED + 1))
            fi
          fi
          ;;
          
        *)
          echo "  ${C_NO}âš  SKIP:${C_RST} Unknown scope: $SCOPE"
          SKIPPED=$((SKIPPED + 1))
          ;;
      esac
      
      echo ""
      
    done <<< "$SELECTED"
    
    # Summary
    echo "${C_HDR}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RST}"
    echo "${C_HDR}Summary${C_RST}"
    echo "${C_HDR}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RST}"
    echo "Total selected:        $TOTAL"
    if [ $DRY_RUN -eq 1 ]; then
      echo "${C_DIM}Would delete local:    $SUCCESS_LOCAL${C_RST}"
      echo "${C_DIM}Would delete remote:   $SUCCESS_REMOTE${C_RST}"
    else
      echo "${C_OK}Deleted local:         $SUCCESS_LOCAL${C_RST}"
      echo "${C_OK}Deleted remote:        $SUCCESS_REMOTE${C_RST}"
      if [ $FAILED -gt 0 ]; then
        echo "${C_NO}Failed:                $FAILED${C_RST}"
      fi
    fi
    if [ $SKIPPED -gt 0 ]; then
      echo "${C_NO}Skipped:               $SKIPPED${C_RST}"
    fi
    echo "${C_HDR}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${C_RST}"
    
    if [ $DRY_RUN -eq 1 ]; then
      echo ""
      echo "${C_CY}ðŸ’¡ Tip: Remove --dry-run flag to actually delete these branches${C_RST}"
    fi
  else
    info "No branches selected."
  fi
  
  exit 0
fi

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Normal Output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
render_output
