#!/bin/zsh

# ============================================================================
# Enhanced Folder & File Cleanup Script
# ============================================================================
# Description:
#   A powerful cleanup utility that searches and removes development artifacts,
#   cache files, and temporary directories with advanced features like size
#   reporting, colored output, logging, and safety confirmations.
#
# Usage:
#   ./cleanup.zsh [OPTIONS]
#
# Options:
#   --dry-run         Show what would be deleted without actually deleting
#   --force           Skip confirmation prompts (use with caution!)
#   --verbose         Show detailed information during operation
#   --log FILE        Save operations to a log file
#   --size            Show sizes of items to be deleted
#   --depth N         Limit search depth (default: unlimited)
#   --patterns FILE   Load custom patterns from file
#   --exclude PATTERN Exclude paths matching this pattern
#   --help            Show this help message
#
# Examples:
#   ./cleanup.zsh --dry-run --size
#   ./cleanup.zsh --force --verbose --log cleanup.log
#   ./cleanup.zsh --depth 3 --exclude "*/important/*"
# ============================================================================

# Enable extended globbing and null_glob
setopt EXTENDED_GLOB NULL_GLOB

# Color codes for pretty output
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    PURPLE='\033[0;35m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    RESET='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' PURPLE='' CYAN='' BOLD='' RESET=''
fi

# Default configuration
DRY_RUN=false
FORCE=false
VERBOSE=false
SHOW_SIZE=false
LOG_FILE=""
MAX_DEPTH=""
CUSTOM_PATTERNS_FILE=""
EXCLUDE_PATTERNS=()

# Comprehensive patterns for cleanup
declare -A PATTERN_CATEGORIES
PATTERN_CATEGORIES[cache]="**/__pycache__ **/.pytest_cache **/.cache **/node_modules/.cache **/*.pyc"
# PATTERN_CATEGORIES[build]="**/build **/dist **/*.egg-info **/target **/.tox"
PATTERN_CATEGORIES[deps]="**/node_modules **/bower_components **/.venv **/venv"
# PATTERN_CATEGORIES[ide]="**/.vscode/settings.json **/.idea **/*.swp **/*.swo **/*~ **/thumbs.db"
PATTERN_CATEGORIES[system]="**/.DS_Store **/.Thumbs.db **/.Trash-* **/desktop.ini"
PATTERN_CATEGORIES[temp]="**/tmp **/temp **/*.tmp **/*.temp **/.*_temp"
PATTERN_CATEGORIES[logs]="**/*.log **/.npm/_logs **/*.log.*"
# PATTERN_CATEGORIES[test]="**/.coverage **/.nyc_output **/*.coverage"

# Statistics
declare -A STATS
STATS[total_items]=0
STATS[total_size]=0
STATS[deleted_items]=0
STATS[errors]=0

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case $level in
        INFO)  echo -e "${GREEN}[INFO]${RESET} $message" >&2 ;;
        WARN)  echo -e "${YELLOW}[WARN]${RESET} $message" >&2 ;;
        ERROR) echo -e "${RED}[ERROR]${RESET} $message" >&2 ;;
        SUCCESS) echo -e "${GREEN}[SUCCESS]${RESET} $message" >&2 ;;
        *)     echo -e "$message" >&2 ;;
    esac
    
    if [[ -n "$LOG_FILE" ]]; then
        echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    fi
}


show_usage() {
    cat << 'EOF'
Enhanced Folder & File Cleanup Script

USAGE:
    ./cleanup.zsh [OPTIONS]

OPTIONS:
    --dry-run         Show what would be deleted without actually deleting
    --force           Skip confirmation prompts (use with caution!)
    --verbose         Show detailed information during operation
    --log FILE        Save operations to a log file
    --size            Show sizes of items to be deleted
    --depth N         Limit search depth (default: unlimited)
    --patterns FILE   Load custom patterns from file
    --exclude PATTERN Exclude paths matching this pattern
    --help            Show this help message

EXAMPLES:
    ./cleanup.zsh --dry-run --size
    ./cleanup.zsh --force --verbose --log cleanup.log
    ./cleanup.zsh --depth 3 --exclude "*/important/*"

PATTERN CATEGORIES:
    cache    - Python cache, pytest cache, general cache directories
    build    - Build artifacts, distribution files
    deps     - Dependencies like node_modules, virtual environments
    ide      - IDE configuration and temporary files
    system   - OS-specific files (.DS_Store, Thumbs.db)
    temp     - Temporary files and directories
    logs     - Log files
    test     - Test coverage and output files
EOF
}

get_size() {
    local path="$1"
    if [[ -d "$path" ]]; then
        du -sh "$path" 2>/dev/null | cut -f1
    elif [[ -f "$path" ]]; then
        ls -lah "$path" 2>/dev/null | awk '{print $5}'
    else
        echo "0B"
    fi
}

get_size_bytes() {
    local path="$1"
    if [[ -d "$path" ]]; then
        du -sb "$path" 2>/dev/null | cut -f1
    elif [[ -f "$path" ]]; then
        stat -c%s "$path" 2>/dev/null || stat -f%z "$path" 2>/dev/null || echo "0"
    else
        echo "0"
    fi
}

format_bytes() {
    local bytes="$1"
    if (( bytes < 1024 )); then
        echo "${bytes}B"
    elif (( bytes < 1048576 )); then
        echo "$(( bytes / 1024 ))KB"
    elif (( bytes < 1073741824 )); then
        echo "$(( bytes / 1048576 ))MB"
    else
        echo "$(( bytes / 1073741824 ))GB"
    fi
}

should_exclude() {
    local path="$1"
    for exclude_pattern in "${EXCLUDE_PATTERNS[@]}"; do
        if [[ "$path" == $~exclude_pattern ]]; then
            return 0
        fi
    done
    return 1
}

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --size)
                SHOW_SIZE=true
                shift
                ;;
            --log)
                LOG_FILE="$2"
                if [[ -z "$LOG_FILE" ]]; then
                    log_message ERROR "Log file not specified"
                    exit 1
                fi
                shift 2
                ;;
            --depth)
                MAX_DEPTH="$2"
                if ! [[ "$MAX_DEPTH" =~ ^[0-9]+$ ]]; then
                    log_message ERROR "Invalid depth: $MAX_DEPTH"
                    exit 1
                fi
                shift 2
                ;;
            --patterns)
                CUSTOM_PATTERNS_FILE="$2"
                if [[ ! -f "$CUSTOM_PATTERNS_FILE" ]]; then
                    log_message ERROR "Patterns file not found: $CUSTOM_PATTERNS_FILE"
                    exit 1
                fi
                shift 2
                ;;
            --exclude)
                EXCLUDE_PATTERNS+=("$2")
                shift 2
                ;;
            --help)
                show_usage
                exit 0
                ;;
            -*)
                log_message ERROR "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                log_message ERROR "Unexpected argument: $1"
                show_usage
                exit 1
                ;;
        esac
    done
}

# ============================================================================
# MAIN FUNCTIONS
# ============================================================================

load_custom_patterns() {
    if [[ -n "$CUSTOM_PATTERNS_FILE" ]]; then
        log_message INFO "Loading custom patterns from $CUSTOM_PATTERNS_FILE"
        while IFS= read -r line; do
            if [[ -n "$line" && ! "$line" =~ ^# ]]; then
                PATTERN_CATEGORIES[custom]+=" $line"
            fi
        done < "$CUSTOM_PATTERNS_FILE"
    fi
}

find_matches() {
    local category="$1"
    local patterns="$2"
    local matches=()
    
    log_message INFO "Searching for ${BOLD}$category${RESET} patterns..."
    
    for pattern in ${=patterns}; do
        local depth_qualifier=""
        if [[ -n "$MAX_DEPTH" ]]; then
            # Note: zsh glob qualifiers don't have built-in depth limiting
            # This is a simplified approach
            depth_qualifier=""
        fi
        
        # Use DN qualifiers: D=include dotfiles, N=nullglob (no error if no match)
        local found=( $~pattern(DN) )
        
        for item in "${found[@]}"; do
            if ! should_exclude "$item"; then
                matches+=("$item")
            fi
        done
    done
    
    echo "${matches[@]}"
}

show_summary() {
    local items=("$@")
    local total_size_bytes=0
    
    if [[ ${#items[@]} -eq 0 ]]; then
        log_message INFO "No items found matching the patterns"
        return
    fi
    
    echo -e "\n${BOLD}=== CLEANUP SUMMARY ===${RESET}"
    echo -e "${BLUE}Found ${#items[@]} items${RESET}\n"
    
    for item in "${items[@]}"; do
        local size=""
        local size_bytes=0
        
        if [[ $SHOW_SIZE == true ]]; then
            size=$(get_size "$item")
            size_bytes=$(get_size_bytes "$item")
            total_size_bytes=$((total_size_bytes + size_bytes))
            size_display=" ${PURPLE}[$size]${RESET}"
        fi
        
        local type_indicator=""
        if [[ -d "$item" ]]; then
            type_indicator="${BLUE}ðŸ“${RESET}"
        else
            type_indicator="${YELLOW}ðŸ“„${RESET}"
        fi
        
        echo -e "  $type_indicator $item$size_display"
    done
    
    if [[ $SHOW_SIZE == true && $total_size_bytes -gt 0 ]]; then
        echo -e "\n${BOLD}Total size: $(format_bytes $total_size_bytes)${RESET}"
        STATS[total_size]=$total_size_bytes
    fi
    
    STATS[total_items]=${#items[@]}
}

perform_cleanup() {
    local items=("$@")
    
    if [[ ${#items[@]} -eq 0 ]]; then
        return
    fi
    
    if [[ $DRY_RUN == true ]]; then
        log_message INFO "DRY RUN: No files were actually deleted"
        return
    fi
    
    if [[ $FORCE != true ]]; then
        echo -e "\n${YELLOW}âš ï¸  WARNING: This will permanently delete ${#items[@]} items${RESET}"
        echo -n "Are you sure you want to continue? [y/N] "
        read -r confirm
        if [[ ! "$confirm" =~ ^[yY]([eE][sS])?$ ]]; then
            log_message INFO "Operation cancelled by user"
            return
        fi
    fi
    
    echo -e "\n${BOLD}=== PERFORMING CLEANUP ===${RESET}"
    
    local deleted_count=0
    local error_count=0
    
    for item in "${items[@]}"; do
        if [[ $VERBOSE == true ]]; then
            echo -n "Deleting: $item ... "
        fi
        
        if rm -rf -- "$item" 2>/dev/null; then
            if [[ $VERBOSE == true ]]; then
                echo -e "${GREEN}âœ“${RESET}"
            fi
            deleted_count=$((deleted_count + 1))
            log_message INFO "Deleted: $item"
        else
            if [[ $VERBOSE == true ]]; then
                echo -e "${RED}âœ—${RESET}"
            fi
            error_count=$((error_count + 1))
            log_message ERROR "Failed to delete: $item"
        fi
    done
    
    STATS[deleted_items]=$deleted_count
    STATS[errors]=$error_count
    
    if [[ $deleted_count -gt 0 ]]; then
        log_message SUCCESS "Successfully deleted $deleted_count items"
    fi
    
    if [[ $error_count -gt 0 ]]; then
        log_message WARN "Failed to delete $error_count items"
    fi
}

show_final_stats() {
    echo -e "\n${BOLD}=== FINAL STATISTICS ===${RESET}"
    echo -e "Items found: ${STATS[total_items]}"
    
    if [[ $DRY_RUN != true ]]; then
        echo -e "Items deleted: ${STATS[deleted_items]}"
        echo -e "Errors: ${STATS[errors]}"
    fi
    
    if [[ ${STATS[total_size]} -gt 0 ]]; then
        echo -e "Total size processed: $(format_bytes ${STATS[total_size]})"
    fi
    
    echo -e "Operation: ${BOLD}$(if [[ $DRY_RUN == true ]]; then echo "DRY RUN"; else echo "COMPLETED"; fi)${RESET}"
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
    echo -e "${BOLD}${CYAN}ðŸ§¹ Enhanced Cleanup Script${RESET}"
    echo -e "${PURPLE}Current directory: $(pwd)${RESET}\n"
    
    parse_arguments "$@"
    
    if [[ -n "$LOG_FILE" ]]; then
        log_message INFO "Logging to: $LOG_FILE"
        echo "# Cleanup Log - $(date)" > "$LOG_FILE"
    fi
    
    load_custom_patterns
    
    local all_items=()
    
    # Process each category
    for category patterns in "${(@kv)PATTERN_CATEGORIES}"; do
        if [[ -n "$patterns" ]]; then
            local matches=($(find_matches "$category" "$patterns"))
            all_items+=("${matches[@]}")
        fi
    done
    
    # Remove duplicates while preserving order
    local unique_items=()
    local seen_items=()
    
    for item in "${all_items[@]}"; do
        if [[ ${seen_items[(ie)$item]} -gt ${#seen_items} ]]; then
            unique_items+=("$item")
            seen_items+=("$item")
        fi
    done
    
    show_summary "${unique_items[@]}"
    perform_cleanup "${unique_items[@]}"
    show_final_stats
    
    log_message INFO "Cleanup process completed"
}

# Run main function with all arguments
main "$@"