#!/usr/bin/env bash
set -euo pipefail

# ───────────────────────── Config / Defaults ─────────────────────────
REMOTE="origin"; AUTHOR_RE=""; ONLY="all"; BASE=""
HELP=0; RAW=0; NO_COLUMN=0
LOG_LEVEL="info"    # info|debug|trace
COLOR_MODE="auto"   # auto|always|never
SORT_COL=""; SORT_DESC=0

# Widths when RAW=0 (prevent macOS column choking)
W_BRANCH=60; W_SCOPE=6; W_UPSTREAM=48; W_UPSTREAMDATE=18
W_MERGED=12; W_PR=12; W_PRSTATE=12; W_DATE=18; W_EMAIL=48

# ───────────────────────── CLI Args ──────────────────────────────────
while [ $# -gt 0 ]; do
  case "$1" in
    -a|--author) AUTHOR_RE="${2:-}"; shift 2;;
    -r|--remote) REMOTE="${2:-}"; shift 2;;
    -b|--base)   BASE="${2:-}"; shift 2;;
    --locals-only) ONLY="local"; shift;;
    --remotes-only) ONLY="remote"; shift;;
    --sort) SORT_COL="${2:-}"; shift 2;;
    --desc) SORT_DESC=1; shift;;
    --raw) RAW=1; shift;;
    --no-column) NO_COLUMN=1; shift;;
    --log-level) LOG_LEVEL="${2:-info}"; shift 2;;
    --color) COLOR_MODE="${2:-auto}"; shift 2;;
    --debug) LOG_LEVEL="debug"; shift;;
    --trace) LOG_LEVEL="trace"; shift;;
    -h|--help) HELP=1; shift;;
    *) printf 'Unknown arg: %s\n' "$1" >&2; exit 2;;
  esac
done

if [ "$HELP" = "1" ]; then
  cat <<'EOF'
Usage: branch_clean [options]
  -a, --author REGEX       Filter by email (regex, case-insensitive)
  -r, --remote NAME        Remote (default: origin)
  -b, --base BRANCH        Base to compare merge against (default: repo default)
      --locals-only        Only local branches
      --remotes-only       Only remote branches
      --sort COL           Sort by: branch|scope|upstream|upstream_updated|merged|pr|pr_state|last_update|email
      --desc               Sort descending
      --raw                Disable truncation (very long lines)
      --no-column          Disable column(1) alignment
      --color MODE         auto|always|never (default: auto)
      --log-level LVL      info|debug|trace
      --debug|--trace      Shorthand for higher log verbosity
Notes:
  * Dates are relative across all ranges (min, hr, day, week, month, year).
  * PR columns use GitHub `gh` + `jq`. If unavailable/empty, they’re "-".
EOF
  exit 0
fi

# ───────────────────────── Logging ───────────────────────────────────
lvl_num(){ case "$1" in trace) echo 3;; debug) echo 2;; info) echo 1;; warn) echo 0;; *) echo 1;; esac; }
LOG_CUR=$(lvl_num "$LOG_LEVEL")
ts(){ date +"%Y-%m-%d %H:%M:%S"; }
log(){ local L="$1"; shift; local N=$(lvl_num "$L"); [ "$N" -le "$LOG_CUR" ] || return 0; echo "[$(ts)] [$L] $*" >&2; }
warn(){ log warn "$@"; }
info(){ log info "$@"; }
dbg(){ log debug "$@"; }
trc(){ log trace "$@"; }

# ───────────────────────── Color Mode ────────────────────────────────
is_tty=0; [ -t 1 ] && is_tty=1
supports_color=0; command -v tput >/dev/null 2>&1 && [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ] && supports_color=1
case "$COLOR_MODE" in
  always) DO_COLOR=1;;
  never)  DO_COLOR=0;;
  *)      DO_COLOR=$(( is_tty && supports_color ));;
esac

# Palette (synthwave-ish). Only used if DO_COLOR=1.
if [ "$DO_COLOR" -eq 1 ]; then
  C_HDR=$'\033[38;5;201m'   # neon magenta
  C_LOC=$'\033[38;5;51m'
  C_REM=$'\033[38;5;141m'
  C_OK=$'\033[38;5;82m'
  C_NO=$'\033[38;5;208m'
  C_CY=$'\033[38;5;45m'     # cyan
  C_DIM=$'\033[2m'
  C_RST=$'\033[0m'
else
  C_HDR=""; C_LOC=""; C_REM=""; C_OK=""; C_NO=""; C_CY=""; C_DIM=""; C_RST=""
fi

# ───────────────────────── Repo / Base Detection ─────────────────────
git rev-parse --git-dir >/dev/null 2>&1 || { echo "Not a git repo." >&2; exit 2; }

if [ -z "${BASE}" ]; then
  if RH=$(git symbolic-ref -q "refs/remotes/${REMOTE}/HEAD" 2>/dev/null); then
    BASE="${RH##refs/remotes/${REMOTE}/}"
  else
    if   git show-ref --verify "refs/remotes/${REMOTE}/main"   >/dev/null 2>&1; then BASE="main"
    elif git show-ref --verify "refs/remotes/${REMOTE}/master" >/dev/null 2>&1; then BASE="master"
    else BASE=$(git rev-parse --abbrev-ref HEAD); fi
  fi
fi
BASE_REF=""
if   git show-ref --verify "refs/remotes/${REMOTE}/${BASE}" >/dev/null 2>&1; then BASE_REF="refs/remotes/${REMOTE}/${BASE}"
elif git show-ref --verify "refs/heads/${BASE}"             >/dev/null 2>&1; then BASE_REF="refs/heads/${BASE}"
else warn "Base '$BASE' not found; MERGED will be '-'."; fi
info "Base: $BASE (ref: ${BASE_REF:-N/A})"

# ───────────────────────── PR preload (GitHub) ───────────────────────
HAVE_GH=0; HAVE_JQ=0
command -v gh >/dev/null 2>&1 && HAVE_GH=1
command -v jq >/dev/null 2>&1 && HAVE_JQ=1
PRMAP=$(mktemp 2>/dev/null || mktemp -t prmap)
trap 'rm -f "$PRMAP" "$OUT" "$REFDATE" "$SORTED" "$TMP_PRINT" 2>/dev/null || true' EXIT

PR_COUNT=0
if [ $HAVE_GH -eq 1 ] && [ $HAVE_JQ -eq 1 ]; then
  if pr_json=$(gh pr list --state all --json number,state,headRefName --limit 1000 2>/dev/null); then
    PR_COUNT=$(printf '%s' "$pr_json" | jq 'length' 2>/dev/null || echo 0)
    if [ "$PR_COUNT" -gt 0 ]; then
      printf '%s' "$pr_json" | jq -r '.[] | "\(.headRefName)\t\(.number)\t\(.state)"' > "$PRMAP" || true
      info "Loaded $PR_COUNT PRs via gh."
    else
      warn "gh returned 0 PRs; auth/context may be missing. Try: gh auth status; gh repo view"
    fi
  else
    warn "gh pr list failed; PR columns will be '-'."
  fi
else
  warn "gh+jq not available; PR columns will be '-'."
fi

# ───────────────────────── Upstream date map ─────────────────────────
REFDATE=$(mktemp 2>/dev/null || mktemp -t refdate)
git for-each-ref --format='%(refname)	%(committerdate:iso-strict)' refs/heads refs/remotes > "$REFDATE"

# ───────────────────────── Date helpers ──────────────────────────────
norm_tz(){ echo "${1}" | sed -E 's@([+-][0-9]{2}):([0-9]{2})$@\1\2@'; }
to_epoch(){ if date -ud "@0" >/dev/null 2>&1; then date -ud "$1" +%s; else date -j -f '%Y-%m-%dT%H:%M:%S%z' "$(norm_tz "$1")" +%s; fi; }
plural(){ local n="$1" w="$2"; if [ "$n" -eq 1 ]; then echo "$n $w ago"; else echo "$n ${w}s ago"; fi; }
rel_or_iso(){
  local iso="$1"; [ -z "$iso" ] && { echo "-"; return; }
  local now epoch delta; now=$(date +%s)
  if ! epoch=$(to_epoch "$iso" 2>/dev/null); then echo "${iso%%T*}"; return; fi
  delta=$(( now - epoch )); [ $delta -lt 0 ] && delta=$(( -delta ))
  local m=$((60)); local h=$((60*m)); local d=$((24*h)); local w=$((7*d))
  local mo=$((30*d)); local y=$((365*d))
  if   [ $delta -lt $m ]; then echo "just now"
  elif [ $delta -lt $h ]; then plural $((delta/m)) "min"
  elif [ $delta -lt $d ]; then plural $((delta/h)) "hour"
  elif [ $delta -lt $w ]; then plural $((delta/d)) "day"
  elif [ $delta -lt $mo ]; then plural $((delta/w)) "week"
  elif [ $delta -lt $y ]; then plural $((delta/mo)) "month"
  else plural $((delta/y)) "year"; fi
}

# ───────────────────────── Gather refs (US-delimited) ────────────────
SEP=$'\x1f'
REF_FMT="%(refname)${SEP}%(refname:short)${SEP}%(upstream:short)${SEP}%(committerdate:iso-strict)${SEP}%(authoremail)"
NS1="refs/heads"; NS2="refs/remotes"; case "$ONLY" in local) NS2="";; remote) NS1="";; esac

OUT=$(mktemp 2>/dev/null || mktemp -t branches_out)
printf "BRANCH\tSCOPE\tUPSTREAM\tUPSTREAM_UPDATED\tMERGED->%s\tPR\tPR_STATE\tLAST_UPDATE\tEMAIL\t__USISO\t__LASTISO\n" "$BASE" >"$OUT"

while IFS="$SEP" read -r REF FULL UPSTREAM LASTISO AEMAIL; do
  [ "$REF" = "refs/remotes/${REMOTE}/HEAD" ] && continue
  case "$REF" in refs/heads/*) SCOPE="local";; refs/remotes/*) SCOPE="remote";; *) SCOPE="-";; esac

  [ -n "$AUTHOR_RE" ] && printf '%s\n' "$AEMAIL" | grep -qiE -- "$AUTHOR_RE" || { [ -n "$AUTHOR_RE" ] && continue; }

  # Upstream display rules
  if [ "$SCOPE" = "remote" ] || [ -z "${UPSTREAM}" ]; then UPSTREAM="-"; fi

  # Merge vs base
  MERGED="-"
  if [ -n "$BASE_REF" ] && [ "$FULL" != "$BASE" ] && [ "$REF" != "$BASE_REF" ]; then
    if git merge-base --is-ancestor "$REF" "$BASE_REF"; then MERGED="yes"; else MERGED="no"; fi
  fi

  # PR lookup
  PRNO="-" PRST="-"
  if [ -s "$PRMAP" ]; then
    if line=$(grep -m1 -F -E "^${FULL}\t" "$PRMAP" 2>/dev/null); then
      PRNO="#$(printf '%s' "$line" | awk -v FS=$'\t' '{print $2}')"
      PRST="$(printf '%s' "$line" | awk -v FS=$'\t' '{print $3}')"
    else
      SHORT="$FULL"; case "$SHORT" in */*) SHORT="${SHORT#*/}";; esac
      if line=$(grep -m1 -F -E "^${SHORT}\t" "$PRMAP" 2>/dev/null); then
        PRNO="#$(printf '%s' "$line" | awk -v FS=$'\t' '{print $2}')"
        PRST="$(printf '%s' "$line" | awk -v FS=$'\t' '{print $3}')"
      fi
    fi
  fi

  LAST_HUMAN=$(rel_or_iso "$LASTISO")

  USISO=""; UPSTREAM_UPDATED="-"
  if [ "$UPSTREAM" != "-" ]; then
    CAND1="refs/remotes/${UPSTREAM}"; CAND2="refs/heads/${UPSTREAM}"
    USISO=$(awk -v FS=$'\t' -v r="$CAND1" '$1==r{print $2; exit}' "$REFDATE" || true)
    [ -z "$USISO" ] && USISO=$(awk -v FS=$'\t' -v r="$CAND2" '$1==r{print $2; exit}' "$REFDATE" || true)
    [ -n "$USISO" ] && UPSTREAM_UPDATED=$(rel_or_iso "$USISO")
  fi

  # Emit TSV (+ hidden ISO fields for sorting)
  printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
    "$FULL" "$SCOPE" "$UPSTREAM" "$UPSTREAM_UPDATED" "$MERGED" "$PRNO" "$PRST" "$LAST_HUMAN" "$AEMAIL" "${USISO:-}"$'\t'"${LASTISO:-}" \
    >>"$OUT"
done < <(
  if [ -n "$NS1" ] && [ -n "$NS2" ]; then
    git for-each-ref --sort=-committerdate --format="$REF_FMT" "$NS1" "$NS2"
  elif [ -n "$NS1" ]; then
    git for-each-ref --sort=-committerdate --format="$REF_FMT" "$NS1"
  else
    git for-each-ref --sort=-committerdate --format="$REF_FMT" "$NS2"
  fi
)

# ───────────────────────── Sorting (uses hidden ISO fields) ─────────
SORTED="$OUT"
if [ -n "$SORT_COL" ]; then
  case "$SORT_COL" in
    branch)           KEY=1;;
    scope)            KEY=2;;
    upstream)         KEY=3;;
    upstream_updated) KEY=10;;   # __USISO
    merged)           KEY=5;;
    pr)               KEY=6;;
    pr_state)         KEY=7;;
    last_update)      KEY=11;;   # __LASTISO
    email)            KEY=9;;
    *) warn "Unknown --sort '$SORT_COL' (ignored)"; KEY="";;
  esac
  if [ -n "${KEY:-}" ]; then
    SORTED="${OUT}.sorted"
    if [ $SORT_DESC -eq 1 ]; then sort -t $'\t' -k "${KEY},${KEY}" -r "$OUT" > "$SORTED"
    else                               sort -t $'\t' -k "${KEY},${KEY}"    "$OUT" > "$SORTED"
    fi
  fi
fi

# Strip hidden fields
TAB=$'\t'
cut -f1-9 "$SORTED" > "${SORTED}.vis" && mv "${SORTED}.vis" "$SORTED"

# ───────────────────────── Truncate (if RAW=0) ──────────────────────
if [ $RAW -eq 0 ]; then
  awk -v FS="$TAB" -v OFS="$TAB" \
      -v WB="$W_BRANCH" -v WS="$W_SCOPE" -v WU="$W_UPSTREAM" -v WUD="$W_UPSTREAMDATE" \
      -v WM="$W_MERGED" -v WP="$W_PR" -v WPS="$W_PRSTATE" -v WD="$W_DATE" -v WE="$W_EMAIL" '
    function trunc(s, w) { nl=index(s,"\n"); if(nl){s=substr(s,1,nl-1)}; return (length(s)>w ? substr(s,1,w-1)"…" : s) }
    NR==1 { print $1,$2,$3,$4,$5,$6,$7,$8,$9; next }
    { $1=trunc($1,WB); $2=trunc($2,WS); $3=trunc($3,WU); $4=trunc($4,WUD);
      $5=trunc($5,WM); $6=trunc($6,WP); $7=trunc($7,WPS); $8=trunc($8,WD); $9=trunc($9,WE);
      print $1,$2,$3,$4,$5,$6,$7,$8,$9 }' "$SORTED" > "${SORTED}.trim"
  mv "${SORTED}.trim" "$SORTED"
fi

# ───────────────────────── Render (column → color) ──────────────────
render_plain() {
  if [ $NO_COLUMN -eq 0 ] && command -v column >/dev/null 2>&1; then
    column -t -s $'\t' < "$SORTED"
  else
    cat "$SORTED"
  fi
}

if [ "$DO_COLR" -eq 0 ]; then
  render_plain
else
  TMP_PRINT=$(mktemp 2>/dev/null || mktemp -t printout)
  render_plain > "$TMP_PRINT"
  # Colorize after alignment without adding/removing characters
  awk -v hdr="$C_HDR" -v loc="$C_LOC" -v rem="$C_REM" -v ok="$C_OK" -v no="$C_NO" -v cy="$C_CY" -v dim="$C_DIM" -v rst="$C_RST" '
    NR==1 { print hdr $0 rst; next }
    {
      gsub(/\<local\>/,  loc "local" rst);
      gsub(/\<remote\>/, rem "remote" rst);
      gsub(/\<YES\>/,    ok "YES" rst);
      gsub(/\<yes\>/,    ok "yes" rst);
      gsub(/\<NO\>/,     no "NO" rst);
      gsub(/\<no\>/,     no "no" rst);
      gsub(/\<open\>/,   ok "open" rst);
      gsub(/\<merged\>/, cy "merged" rst);
      gsub(/\<closed\>/, no "closed" rst);
      gsub(/\<draft\>/,  dim "draft" rst);
      print
    }' "$TMP_PRINT"
  rm -f "$TMP_PRINT"
fi
